\documentclass[a4paper]{extarticle}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\selectlanguage{italian}
\usepackage[table]{xcolor}
\usepackage{xcolor}
\usepackage{circuitikz}
\usetikzlibrary{positioning, circuits.logic.US}
\usetikzlibrary{shapes.geometric, arrows}
\usetikzlibrary {shapes.gates.logic.US, shapes.gates.logic.IEC, calc}
\tikzset {branch/.style={fill, shape = circle, minimum size = 3pt, inner sep = 0pt}}
\usetikzlibrary{matrix,calc}
\usepackage{multirow}
\usepackage{float}
\usepackage{geometry}
\usepackage{tabularx}
\usepackage{pgf-pie}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color, soul}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{listings}
\graphicspath{ {./img/} }
\newtheorem{theorem}{Teorema}[section]
\newtheorem{corollary}{Corollario}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

% Specifiche
\geometry{
 a4paper,
 top=20mm,
 left=30mm,
 right=30mm,
 bottom=30mm
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LO]{\nouppercase{\leftmark}}
\fancyfoot[CE, CO]{\thepage}
\addtolength{\headheight}{1em}
\addtolength{\footskip}{-0.5em}

\newcommand{\quotes}[1]{``#1''}
\renewcommand\tabularxcolumn[1]{>{\vspace{\fill}}m{#1}<{\vspace{\fill}}}
\renewcommand\arraystretch{}
\newcolumntype{P}{>{\centering\arraybackslash}X}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\title{\textbf{Università di Trieste\\ \vspace{1em}
Laurea in ingegneria elettronica e informatica}}
\author{Enrico Piccin - Corso di Fondamenti di informatica - Prof. Sylvio Barbon Junior}
\date{Anno Accademico 2021/2022 - 1 Marzo 2022}

\begin{document}

\vspace{-10mm}
\maketitle

\tableofcontents
\newpage
\lstlistoflistings
\newpage

\noindent
\begin{center}
  1 Marzo 2022
\end{center}

\section{Introduzione a Java}
\textbf{Java} è un linguaggio di programmazione rigido e fortemente tupizzato, ovvero esige la dichiarazione di tutte le vairabili, con il loro tipo e con una loro inizializzazione. La \textbf{struttura formale} del linguaggio, pertanto, è predomincante ed è ciò che caratterizza Java rispetto ad altri linguaggi di programmazione, come \emph{Python} o \emph{PHP}.\\
Java, inoltre, è un linguaggio che opera al di sopra del sistema operativo, eliminando l'interdipendenza con il substrato software che permette l'esecuzione dei programmi: in altre parole, cambiando il sistema operativo non cambia il \textbf{codice sorgente}, ma solamente la piattaforma sulla quale esso viene eseguito; si dice, in tale caso, che \textbf{Java è un linguaggio portabile}.\\
Tuttavia, se da un lato tale impostazione costituisce un vantaggio, dall'altro rappresenta anche un limite: a parità di programma da eseguire, un programma scritto in Java sarà più lento, nell'esecuzione, di un programma scritto in C, per esempio, il quale è fortemente dipendente dall'ambiente software di esecuzione e permette di controllarne la gestione della memoria e dell'indirizzamento al fine di ottenere un'ottimizzazione massima. Questo in quanto Java è un \textbf{linguaggio interpretato}, che necessita prima di una \textbf{pseucodifica} per essere seguito su una \textbf{macchina virtuale}, mentre C è un \emph{linguaggio compilato direttamente} sfruttrando la struttura del sistema operativo nativo.

\vspace{1em}
\subsection{Editor}
La realizzazione di un programma in Java parte dalla scrittura del \emph{codice sorgente} mediante un \textbf{editor}, anche chiamate \textbf{IDE} (dall'inglese \emph{Integrated Development Environment}), ossia un programma di utilità che consente di inserire e memorizzare un testo e di modificarlo successivamente per effettuare aggiunte o correzioni.

\vspace{1em}
\subsection{Compilazione}
Il codice sorgente scritto in Java che, proprio per questo, presenta estensione \textbf{.java}, al fine di poter essere eseguito dalla macchina, deve essere \textbf{compilato} da un \textbf{compilatore} (che nel caso di Java è il \textbf{javac}, o \textbf{JDK}, il quale permette di trasformare delle istruzione elaborate con un linguaggio \emph{user-oriented} (di \textbf{alto livello}) in un linguaggio \emph{machine-oriented} (di \textbf{basso livello}), ovverosia più vicino alla macchina, tale per cui la macchina lo possa comprendere ed eseguire. Nel caso di Java, la \quotes{macchina} che andrà ad eseguire le istruzioni così tradotte è una \textbf{macchina virtuale}, mentre nel caso del linguaggio C, la compilazione serve ad ottimizzare il programma finale, grazie alla forte interdipendenza tra linguaggio di programmazione e hardware sottostante.\\
Il risultato della compilazione di un codice sorgente .java è il \textbf{codice compilato} (o \textbf{bytecode}), con estensione \textbf{.class}: esso non deve essere più compilato e può essere eseguito su ogni piattaforma hardware-software.

\vspace{1em}
\subsection{Lettura e interpretazione}
Il codice compilato (o bytecode), viene letto dal \textbf{loader}, ossia dalla macchina virtuale \textbf{java} \textbf{JRE}, la quale effettua la verifica del codice compilato (\textbf{bytecode verifier}) e ne interpreta le istruzioni.

\vspace{1em}
\subsection{Ambienti}
Il linguaggio Java, per quello che si è detto, è un \textbf{linguaggio portabile} (in quanto può essere eseguito in diversi ambienti hardware e software) e un \textbf{linguaggio ad oggetti puro}, in quanto si basa sul \textbf{paradigma di programmazione orientato agli oggetti} (OOL, Object Oriented Language). Due, inolre, sono delle tecnologie che permettono una maggiore gestione dei programmi:
\begin{enumerate}
  \item \textbf{Garbage Collector}: tool di gestione della memoria, per motivi di sicurezza e di semplicità di programmazione, pulendo ed elimando locazioni di memoria inutilizzate;
  \item \textbf{Multithreading}: tecnologia che consente la gestione dell'esecuzione contemporanea di più task all'interno della stessa applicazione. Il processore, tramite la tecnologia \textbf{time sharing} permette di gestire lo scheduling dei processi in modo tale da permettere un'esecuzione quanto più simultanea delle diverse task.
\end{enumerate}
La tecnologia Java, infine, si avvale di tre importanti tool per la sua esecuzione:
\begin{enumerate}
  \item \textbf{JDK} (Java Development Kit): un set completo di \textbf{API} (librerie di funzioni precostituite che consentono di eseguire operazioni automaticamente) e una serie di tool per lo sviluppo di applicazioni Java;
  \item \textbf{JSE} (Java Standard Edition): pacchhetto base per lo sviluppo di normali applicazioni Java (che possono andare dagli \textbf{Applets} a \textbf{Desktop applications} con \emph{Swing} o \emph{Java FX} per l'interfaccia grafica). Esistono anche \textbf{JEE} (Java Enterprise Edition) per lo sviluppo di applicazioni server di grandi aziende e \textbf{JME} (Java Mobile Edition) per lo sviluppo di applicazioni mobile.
  \item \textbf{JRE} (Java Runtime Environment), ambiente per l'esecuzione delle applicazioni Java tramite \textbf{JVM}, o Java Virtual Machine.
\end{enumerate}

\vspace{1em}
\subsection{Linguaggi di programmazione}
I linguaggi di programmazione si possono suddividere in due grandi categorie:
\begin{enumerate}
  \item linguaggi di \textbf{basso livello} (\textbf{linguaggi macchina} e Assembly), che sono, quindi, linguaggi che il calcolatore è in grado di comprendere;
  \item \textbf{linguaggi ad alto livello} o \textbf{linguaggi evoluti}, quindi più vicini al programmatore e che consentono l'uso di \textbf{nomi simbolici} che corrispondono a più set di istruzioni linugaggio macchina.
\end{enumerate}

\vspace{1em}
\noindent
\subsection{Programmi traduttori: compilatore e interprete}
Di seguito si espone la definzione di \textbf{compilatore}:

% Tabella per le definizione di concetti, etc...
\vspace{1em}
\rowcolors{1}{black!5}{black!5}
\setlength{\tabcolsep}{14pt}
\renewcommand{\arraystretch}{2}
\noindent
\begin{tabularx}{\textwidth}{@{}|P|@{}}
    \hline
    {\textbf{COMPILATORE}}\\
    \parbox{\linewidth}{Il \textbf{compilatore} è un programma che traduce un programma sorgente scritto in linguaggio ad alto livello in un programma oggetto in linguaggio macchina.\\
    Esso, inoltre, svolge tre importanti funzioni di analisi:
    \begin{enumerate}
      \item \textbf{analisi lessicale}: consente di individuare le parole chiave e riservate del linguaggio di programmazione, ccosì come del vocabolario e permette di costruire la tabella dei simboli;
      \item \textbf{analisi sintattica}: ossia il controllo della correttezza delle istruzioni al fine di verificare se essse sono scritte rispettando la sintassi del linguaggio Java, cioé le regole della grammatica;
      \item \textbf{analisi semantica}: ovvero il controllo della validità del significato degli elementi in base al contesto (per esempio la presenza delle istruzioni dichiarative necessarie).
    \end{enumerate}
    \vspace{-1mm}}\\
    \hline
\end{tabularx}

\vspace{1em}
\noindent
Pertanto il compilatore individua e segnala tutti gli \textbf{errori formali}: se vi sono errori, la traduzione non può avvenire. Se non ci sono errori, il compilatore passa alla fase di sintesi durante la quale viene generato il codice oggetto, di solito in formato rilocabile.\\
Sarà poi compito del \textbf{linker} trasformare il programma oggetto in programma eseguibile (con estensione .class), il quale verrà poi eseguito dalla macchina virtuale JVM grazie all'\textbf{interprete} che traduce le istruzioni del linguaggio ad alto livello in linguaggio macchina, una per una, al momento dell’esecuzione.\\
Durante il \textbf{runtime} vengono anche rilevati degli errori di esecuzione, dovuti non alla scorrettezza formale del codice sorgente, ma ad un uso scorretto del programma.\\
L'impiego di un compilatore o di un inteprete presenta una serie di vantaggi e di svantaggi:

\begin{figure}[H]
  \centering
  \rowcolors{1}{white}{white}
  \begin{tabularx}{\textwidth}{@{}|P|P|@{}}
    \hline
    \textbf{Compilatore} & \textbf{Interprete}\\
    \hline
    \rowcolor{blue!5}
    \multicolumn{2}{|c|}{\textbf{VANTAGGI}}\\
    \hline
    \parbox{\linewidth}{maggior velocità di esecuzione} & \parbox{\linewidth}{\vspace{3mm} semplicità di messa a punto dei programmi poiché si lavora in ambiente interattivo \vspace{3mm}}\\
    \hline
    \parbox{\linewidth}{risparmio di memoria} & \parbox{\linewidth}{maggior portabilità dei programmi}\\
    \hline
    \parbox{\linewidth}{rilevazione di tutti gli errori formali} & \\
    \hline
    \parbox{\linewidth}{\vspace{3mm} consente la segretezza del programma sorgente, in quanto dopo essere stato compilato non è possibile risalire al codice di partenza \vspace{3mm}} & \\
    \hline
    \parbox{\linewidth}{non è necessario codice aggiuntivo} & \\
    \hline
    \rowcolor{red!5}
    \multicolumn{2}{|c|}{\textbf{SVANTAGGI}}\\
    \hline
    \parbox{\linewidth}{\vspace{3mm} tempi di creazione del programma più lunghi, per la ricerche di librerie e funzioni specifiche \vspace{3mm}} & \parbox{\linewidth}{maggiore occupazione di memoria}\\
    \hline
    \parbox{\linewidth}{minore portabilità} & \parbox{\linewidth}{l’esecuzione risulta più lenta}\\
    \hline
     & \parbox{\linewidth}{non dà garanzia di correttezza sintattica}\\
    \hline
     & \parbox{\linewidth}{\vspace{3mm} non consente la segretezza del codice sorgente \vspace{3mm}}\\
    \hline
  \end{tabularx}
  \caption{Vantaggi e svantaggi del compilatore e dell'interprete}
  \label{fig:vantaggi_svantaggi_compilatore_interprete}
\end{figure}

\noindent
\textbf{Osservazione}: Si osservi che Java è \textbf{parzialmente compilato} e \textbf{interpretato}.

\vspace{1em}
\subsection{Soluzione di problemi con il calcolatore}
In informatica, un \textbf{problema} è una qualsiasi situazione alla quale è necessario trovare una soluzione. Per la risoluzione di un problema è necessario analizzare diversi elementi
\begin{enumerate}
  \item la situazione iniziale (quali sono i dati del problema): i dati che riguardano il problema sono tutte le informazioni disponibili all’inizio e quelle che si desiderano ottenere come soluzione del problema;
  \item che cosa si desidera ottenere (risultati): le azioni che possono essere eseguite nel processo risolutivo sono le operazioni che il computer è in grado di eseguire; l'insieme delle istruzione costituisce l'\textbf{algoritmo};
  \item le risorse a disposizione, variabili a seconda dell'hardware sottostante.
\end{enumerate}

\vspace{1em}
\noindent
\subsection{Algoritmo e programma}
Di seguito si espone la definizione di \textbf{algoritmo}:

% Tabella per le definizione di concetti, etc...
\vspace{1em}
\rowcolors{1}{black!5}{black!5}
\setlength{\tabcolsep}{14pt}
\renewcommand{\arraystretch}{2}
\noindent
\begin{tabularx}{\textwidth}{@{}|P|@{}}
    \hline
    {\textbf{ALGORITMO}}\\
    \parbox{\linewidth}{Un algoritmo è un procedimento che permette di ottenere dei risultati (dati in uscita o di \textbf{output}) partendo da alcuni dati iniziali (dati di ingresso o di \textbf{input}).\\
    L’algoritmo deve essere
    \begin{enumerate}
      \item \textbf{generale}: non deve risolvere un singolo caso particolare, ma tutta una serie di problemi dello stesso tipo;
      \item \textbf{deterministico}: i risultati devono essere sempre gli stessi, partendo dagli stessi dati iniziali, cioè l'esito dell'esecuzione dell'agoritmo non deve dipendere da aleatorietà o effetti casuali.
    \end{enumerate}
    \vspace{-1mm}}\\
    \hline
\end{tabularx}

\vspace{1em}
\noindent
Il \textbf{programma}, invece, si ottiene codificando l’algoritmo in un \textbf{linguaggio di programmazione}, cioè scrivendo le istruzioni dell’algoritmo secondo la sintassi del linguaggio scelto.

\newpage
\begin{center}
  4 Marzo 2022
\end{center}

\section{Pratica di programmazione in Java}
Si consideri il seguente esempio di codice Java, ovvero il codice sorgente:

\begin{lstlisting}[language=Java, caption=Esempio di codice sorgente in Java]
  public class Java1
  {
    public static void main(String args[]) {
      System.out.println("Ciao mondo!");
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
Da osservare che il nome del file \textbf{Java1.java} deve essere lo stesso della classe principale. All'interno del codice vi sono diverse \textbf{parole riservate} che vengono opportunamente segnalate con una colorazione differente: essendo riservate, esse non possono essere utilizzate dal programmatore per il proprio codice sorgente, ma solamente per la definizione di codice strutturale.\\
La parola riservata \emph{class} è la base del paradigma di programazione orientato agli oggetti. Il \textbf{metodo principale} \emph{main} viene così chiamato perché è il metodo centrale del programma; inoltre la sua stringa di definizione serve per indicare che il proramma può richiedere memoria per essere eseguito.\\
La \textbf{keyword} \emph{void} indica che tale metodo non ritorna nessun valore dopo la sua esecuzione, mentre \emph{static} significa che al metodo viene assegnato un \textbf{indirizzo di memoria fisso} (statico), per cui è possibile richiamare il programma per la sua esecuzione, il quale verrà eseguito in una parte di memoria statica. La \textbf{keyword} \emph{public} sta ad indicare che tale funzione è visibile globalmente e può essere richiamata, quindi eseguita, anche da altri programmi.\\
Le parentesi graffe servono per racchiudere al loro interno uno \textbf{scope}, ovverosia un'ambiente limitato, in cui le dichiarazioni e le funzioni in esso presenti sono valide solamente all'interno dello scope stesso e non possono essere viste esternamente.\\
La riga $5$ rappresenta il vero e proprio programma e, richiamando un metodo (\emph{println}) presente all'interno di una sub-libreria (\emph{out}) di una libreria del sistema operativo (\emph{System}), permette di scrivere a schermo la \textbf{stringa} \quotes{Ciao mondo!} (si potrebbe anche stmpare un numero).\\
Dopo aver elaborato il proprio codice sorgente, si procede alla compilazione dello stesso: ogni possibile errore di sintassi o di struttura del programma viene segnalato dal compilatore stesso.\\
Per la compilazione è sufficiente scrivere

\begin{lstlisting}[language=Java, caption=Esempio di compilazione in Java]
  javac Java1.java
\end{lstlisting}

\vspace{1em}
\noindent
Se la compilazione va a buon fine si ottiene il codice compilato \textbf{Java1.class} e per la sua esecuzione è sufficiente scrivere

\begin{lstlisting}[language=Java, caption=Esempio di esecuzione in Java]
  java Java1
\end{lstlisting}

\vspace{1em}
\subsection{Computabilità}
Di seguito si fornisce la definizione di \textbf{computabilità}:

% Tabella per le definizione di concetti, etc...
\vspace{1em}
\rowcolors{1}{black!5}{black!5}
\setlength{\tabcolsep}{14pt}
\renewcommand{\arraystretch}{2}
\noindent
\begin{tabularx}{\textwidth}{@{}|P|@{}}
    \hline
    {\textbf{COMPUTABILITÀ}}\\
    \parbox{\linewidth}{Un problema si dice \textbf{computabile} se la sua soluzione può essere descritta mediante un algoritmo. Per contro, i problemi che non sono risolvibili con un procedimento algoritmico si dicono \textbf{non computabili}.\vspace{3mm}}\\
    \hline
\end{tabularx}

\newpage
\noindent
\subsection{Paradigma di programmazione}
Al fine di permettere una corretta computabilità del proprio codice è necessario presciegliere il paradigma di programmazione più adatto alla risoluzione del problema. Di seguito si fornisce la definizione di \textbf{paradigma di programmazione}:

% Tabella per le definizione di concetti, etc...
\vspace{1em}
\rowcolors{1}{black!5}{black!5}
\setlength{\tabcolsep}{14pt}
\renewcommand{\arraystretch}{2}
\noindent
\begin{tabularx}{\textwidth}{@{}|P|@{}}
    \hline
    {\textbf{PARADIGMA DI PROGRAMMAZIONE}}\\
    \parbox{\linewidth}{Un \textbf{paradigma di programmazione} è un modello che permette di descrivere astrattamente l’algoritmo (cioè il metodo di soluzione di un problema).\vspace{3mm}}\\
    \hline
\end{tabularx}

\vspace{1em}
\noindent
La  descrizione  dei  dati  e  delle  azioni  per risolvere il problema dipende dal \textbf{paradigma di programmazione} utilizzato e per linguaggi che  usano  lo  stesso  paradigma,  almeno parzialmente  dal  linguaggio  scelto: infatti potrebbero essere disponibili per esempio tipi o strutture di dati diverse.\\
I principali paradigmi di programmazione sono:
\begin{itemize}
  \item il paradigma \textbf{dichiarativo}, il quale descrive \textbf{come} deve essere risolto un problema;
  \item il paradigma \textbf{procedurale}, il quale descrive \textbf{che cosa} si vuole ottenere;
\end{itemize}

\vspace{1em}
\subsubsection{Paradigma dichiarativo}
La programmazione con il \textbf{paradigma dichiarativo} si può suddividere in:
\begin{itemize}
  \item \textbf{programmazione logica}: descrive i fatti e le relazioni tra i fatti e permette di ricavarne delle conseguenze, quale [PROLOG];
  \item \textbf{programmazione funzionale}: il programma è costituito da un insieme di funzioni che elaborano liste di simboli, quale [LISP];
  \item \textbf{linguaggi di markup}: usano dei codici (\emph{tag}) per stabilire il ruolo degli elementi, quale [HTML];
  \item \textbf{linguaggi di interrogazione di database}, quale [SQL].
\end{itemize}

\vspace{1em}
\subsubsection{Paradigma procedurale}
La programmazione con il \textbf{paradigma procedurale} si può suddividere in:
\begin{itemize}
  \item \textbf{programmazione imperativa}: si basa su esplicite richieste fatte all’esecutore del programma; la soluzione del problema è descritta come una sequenza di azioni che producono dei cambiamenti di stato nell’ambiente (come la modifica del valore delle variabili); esempi di tali linguaggi sono Assembler, pascal, C, Cobol;
  \item \textbf{programmazione orientata agli oggetti}: parte dal concetto di oggetto che descrive proprietà e azioni che un oggetto può compiere; la soluzione del problema è descritta dalle interazioni tra gli oggetti; esempi di tali linguaggi sono Java, C++, C\#, Python.
\end{itemize}

\vspace{1em}
\subsection{Linguaggio imperativo}
Il vocabolario usato da ciascun linguaggio comprende delle parole riservate e delle parole che possono essere definite dal programmatore seguendo alcune semplici regole.
\begin{itemize}
  \item Le parole \textbf{riservate} permettono di definire i dati e di scrivere le istruzioni;
  \item Le parole \textbf{definite} dal programmatore (o \textbf{identificatori}) sono in genere i nomi delle variabili e i nomi delle procedure da richiamare.
\end{itemize}

\vspace{1em}
\noindent
\textbf{Esempio}: Si consideri il seguente esempio di codice Java che permette di realizzare una somma tra due numeri costanti ($3+4$):

\begin{lstlisting}[language=Java, caption=Somma di due numeri costanti in Java]
  public class Somma
  {
    public static void main(String args[]) {
      int num1, num2, somma; // Dichiarazione delle variabili senza inzializzazione

      num1=3; // Assegnazione del valore 3 alla variabile num1
      num2=4; // Assegnazione del valore 4 alla variabile num2

      somma=num1+num2;

      System.out.println(num1 + "+" + num2 + "=" + Integer.toString(somma));
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
Pertanto, la sintassi di dichiarazione di una variabile è la seguente

\begin{lstlisting}[language=Java, caption=Dichiarazione di una variabile in Java]
  [modificatore] tipo_di_dato nome_della_variabile [=inizializzazione];
\end{lstlisting}

\noindent
Per \emph{[modificatore]} è da intendersi una specifica della visibilità della variabile (protected, private o public).\\
Il \emph{tipo di dato} da specificare è essenziale, in quanto in base ad esso si ha una differente gestione della memoria.\\
Anche il \emph{nome della variabile} è fondamentale, in quanto esso deve essere \textbf{significativo} e deve aiutare il prgorammatore nella memorizzazione delle variabili dichiarate e da impiegare. È molto utile in questo l'utilizzo della notazione \textbf{camelCase}, che prevede di indicare la prima letterea di una parola in maiuscolo e il restante in minuscolo:
se si considera una \emph{variabile}, essa deve essere scritta con iniziale minuscola e poi impiegando la notazione camelCase, così come per una \emph{funzione}; se si consiera una \emph{costante}, essa vine scritta tutta in maisucolo; se si considera una \emph{classe}, essa avrà l'iniziale maiucola: questo anche perché il linguaggio Java è \textbf{case-sensitive}.\\
Le variabili, naturalmente, devono essere interpretate come delle regioni di memoria, limitate e non immutabili, in cui vengono memorizzate informazioni di diversa natura. È possibile, naturalmente, riservare al proprio programma diverse regioni di memoria, con un limite di dimensione, ovviamente, e specificando in maniera esplicita la tipologia di informazione da memorizzare.
Ovviamente esiste una sostanziale differenza tra dichiarazione di una variabile e innizializzazione della stessa: infatti, è possibile dichiarare una variabile senza bisogno di inizializzarla.\\
Da notare, tuttavia, che la dichiarazione deve sempre essere preceduta dalla specifica della tipologia di dato; ogni assegnazione (che rappresenta un aggiornamento del contenuto informativo della variabile), invece, eccezion fatta per l'inizializzazione, non deve mai essere preceduta dalla specifica della tipologia del dato.\\
Naturalmente, una variabile viene utilizzata per contenere delle informazioni, le quali possono essere recuperate semplicemente specificando il nome della variabiele di interesse all'interno del programma.

\vspace{1em}
\noindent
\textbf{Osservazione}: Naturalmente le stringhe esplicite, all'interno del progrmma, devono essere sempre rcchiuse dalle dalle virgolette, mentre affinché una variabile venga letta e interpretata come tale deve essere specificata con solo il suio nome e non tra le virgolette.\\
La concatenazione delle stringhe, nel linguaggio Java, avviene tramite il simbolo di addizione \quotes{$+$}.\\
Naturalmente, per commentare parti di codice si utilizza una sequenza di caratteri racchiusa tra \quotes{/*} e \quotes{*/} (\textbf{commento tradizionale}), oppure tra \quotes{//} e un terminatore di linea (commento di fine linea). Naturalmente, le parti di codice che vengono contrassegnate come commento, all'interno del programma verranno totalmente ignorate e non compilate dal compilatore stesso.\\
La conversione da stringa a intero avviene grazie al metodo \textbf{toString()} della libreria \textbf{Integer}, il quale prende come parametro proprio la stringa da convertire. In questo caso, la libreria impiegata è stata elaborata da un'altro svilupatore, il quale l'ha messa a disposizione del linguaggio Java e fancendo sì che essa possa essere richiamata senza bisogno di codice aggiuntivo.

\vspace{1em}
\subsection{Errori in Java}
Un esempio molto comune di \textbf{errore} in Java è quello \textbf{di sintassi}, che recita: \quotes{\textbf{cannot find symbol}}: tale errore si verifica quando viene utilizzato all'interno del codice una variabile non dichiarata o un comando non previsto dal liguaggio Java stesso; Il messaggio di errore \quotes{; expected} indica che un'istruzione non è stata terminata correttamente dal punto-vrigola, il quale è un elemento fondameentale nella programmazione per segnalare a Java che un'istruzione è stata terminata.\\
Un \textbf{errore}, invece, \textbf{di esecuzione}, a differenza di un errore di programmazione o sintassi come quelli precedenti, come una \textbf{Exception}, è un errore che il programmatore commette nel definire le operazioni del programma (come dividere zero per zero o aprire un file inesistente, o accedere a delle posizioni di un array fuori range, per esempio) e, quindi, non genera un messaggio di errore da parte del compilatore in fase di compilazione, ma è un errore che si palesa durante l'esecuzione (si parla, in questo caso, di \textbf{Runtime Exception}).\\
Un \textbf{errore logico}, invece, è un errore che il programmatore commette nel definire la logica della programmazione: pertanto la sintassi è corretta e le operzioni che il programma deve svolgere sono corrette; tuttavia ciò che il programma deve fare non è corretto in termini logici. Questo, ovviamente, è il più difficile da individuare: è il cosiddetto \textbf{bug};

\newpage
\noindent
\begin{center}
  7 Marzo 2022
\end{center}

\section{I dati in Java}
L’algoritmo non è soltanto un \textbf{insieme di istruzioni}; una componente fondamentale dell’algoritmo è costituita dai \textbf{dati} e una fase essenziale della stesura dell’algoritmo è la scelta dei dati da utilizzare.\\
Java è un linguaggio \textbf{strongly typed}, ovvero di \textbf{tipicizzazione stretta}. I dati, in particolare, sono di due tipi
\begin{itemize}
  \item dati di \textbf{input}: l'utente deve fornire un input al programma per l'esecuzione
  \item dati di \textbf{output}: il risultato dell'elaborazione, cioé i dati che il programma restituisce all'utente
\end{itemize}
mentre i \textbf{tipi di dati} sono due categorie
\begin{enumerate}
  \item Primitivi
  \begin{enumerate}
    \item Integral
    \begin{enumerate}
      \item Primitivi
      \item boolean
      \item byte
      \item short
      \item int
      \item long
      \item char
      \item float
    \end{enumerate}
    \item Floating
    \begin{enumerate}
      \item float
      \item double
    \end{enumerate}
    \item enumerate
  \end{enumerate}
  \item Derivati
  \begin{enumerate}
    \item array
    \item class
    \item interface
  \end{enumerate}
\end{enumerate}

\vspace{1em}
\noindent
I tipi di dati primitivi maggiormente utilizzati sono

\vspace{1em}
\noindent
\rowcolors{1}{white}{white}
\begin{tabularx}{\textwidth}{|P|P|}
  \hline
  \rowcolor{green}
  Tipo Primitivo & Descrizione\\
  \hline
  \textbf{boolean} & valori che possono essere \emph{true} o \emph{false}\\
  \hline
  \textbf{char} & caratteri di $16$ bit (UNICODE)\\
  \hline
  \textbf{byte} & interi di $8$ bit con segno\\
  \hline
  \textbf{short} & interi di $16$ bit con segno\\
  \hline
  \textbf{int} & interi di $32$ bit con segno\\
  \hline
  \textbf{long} & interi di $64$ bit con segno\\
  \hline
  \textbf{float} & reali di $32$ in virgola mobile\\
  \hline
  \textbf{double} & reali di $64$ bit\\
  \hline
\end{tabularx}

\vspace{1em}
\noindent
Da notare che una variabile di tipo primitivo può essere utilizzata direttamente (senza la clausola \textbf{new}).

\vspace{1em}
\subsection{Booleano}
Il tipo \textbf{boolean} (booleano) ha come insieme di valori le due costanti simboliche \emph{true} e \emph{false}.\\
Con elementi di questo tipo si possono effettuare delle operazioni logiche, le quali producono come risultato un valore booleano. Esse sono:
\begin{enumerate}
  \item \quotes{$\vert$}, ossia barra verticale o \quotes{pipe}, che corrisponde ad un OR logico (disgiunzione);
  \item \quotes{\^}, ossia un apice, che corrisponde ad un OR-ESCLUSIVO logico o XOR;
  \item \quotes{\&}, ossia la \quotes{E} commerciale, che corrisponde ad un AND logico (congiunzione);
  \item \quotes{!}, ossia il punto esclamativo, che corrisponde ad un NOT logico (negazione);
  \item \quotes{==}, ossia un \quotes{doppio uguale}, che corrisponde ad un'uguaglianza;
  \item \quotes{!=}, che corrisponde al \quotes{diverso};
\end{enumerate}

\vspace{1em}
\noindent
Si consideri l'esempio seguente:

\begin{lstlisting}[language=Java, caption=Comparazione tra due numeri costanti in Java]
  public class Comparazione
  {
    public static void main(String args[]) {
      int x = 5;

      System.out.println(x + "== 4" + (x==4));
    }
  }
\end{lstlisting}

\vspace{1em}
\subsection{Intero}
Un tipo \textbf{intero} ha per valori tutti i numeri interi compresi fra $-2^{n-1}$ e $+2^{n-1} - 1$, dove $n$ è il numero di bit usati per la sua rappresentazione.\\
Con elementi di questo tipo \textbf{int} si possono eseguire operazioni elementari, che sono:
\begin{enumerate}
  \item \quotes{$+$}, somma;
  \item \quotes{$-$}, sottrazione;
  \item \quotes{$\ast$}, moltiplicazione;
  \item \quotes{$/$}, quoziente della divisione;
  \item \quotes{$\%$}, resto della divisione;
  \item \quotes{$++$}, incremento di una unità;
  \item \quotes{$--$}, decremento di una unità;
\end{enumerate}
È possibile anche eseguire il \textbf{confronto} tra dati di tipo intero, quali
\begin{enumerate}
  \item \quotes{$==$}, uguale;
  \item \quotes{$!=$}, diverso;
  \item \quotes{$>$}, maggiore;
  \item \quotes{$>=$}, maggiore o uguale;
  \item \quotes{$<$}, minore;
  \item \quotes{$<=$}, minore o uguale;
\end{enumerate}
ancora una volta, il risultato di tale comparazione è un valore booleano. I numeri interi possono esssere convertiti anche in caratteri, seguendo la codifica della tabella ASCII, come mostrato di seguito:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Conversione da intero a carattere in Java]
  public class ConversioneASCII
  {
    public static void main(String args[]) {
      int x = 44;
      int y = 65;

      System.out.println("x = " + x);
      System.out.println("x = " + char(x));
      System.out.println("y = " + y);
      System.out.println("y = " + char(y));
    }
  }
\end{lstlisting}
\vspace{1em}

\noindent
Con gli \textbf{interi} è possibile effettuare \textbf{operazioni bit a bit}, che richiedono, in ogni caso, delle conoscenze sulle rappresentazione dei numeri interi e vengono utilizzate raramente: si impiegano quando si necessita di lavorare ad un basso livello:

\vspace{1em}
\noindent
\rowcolors{1}{white}{white}
\begin{tabularx}{\textwidth}{|P|P|}
  \hline
  \rowcolor{green}
  \multicolumn{2}{|c|}{\textbf{Operazioni bit a bit}}\\
  \hline
  \textbf{~} & complemento (unario) bit a bit\\
  \hline
  \textbf{\&} & AND bit a bit\\
  \hline
  \textbf{$\vert$} & OR bit a bit\\
  \hline
  \textbf{\^} & OR ESCLUSIVO bit a bit\\
  \hline
  \textbf{$<<$} & traslazione a sinistra della distanza specificata inserendo bit uguali a $0$\\
  \hline
  \textbf{$>>$} & traslazione a destra della distanza specificata replicando il segno (bit più significativo)\\
  \hline
  \textbf{$>>>$} & traslazione a destra della distanza specificata inserendo bit uguali a $0$\\
  \hline
\end{tabularx}

\vspace{1em}
\subsection{Floating}
Con i dati di tipo \quotes{floating} possono essere rappresentati i tipi reali:
\begin{enumerate}
  \item $+,-$, ossia più unario e meno unario
  \item $++,--$, incremento e decremento
  \item $+,-$, somma e sottrazione
  \item $\ast,/$, moltiplicazione e divisione reale
  \item $\%$ resto $\boldsymbol{r}$ della divisione reale fra $n$ e $d$, ossia
  \[\boldsymbol{r} = n - d \ast q\]
\end{enumerate}
Si consideri, a tal proposito, il seguente esempio:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Operazioni reali in Java]
  public class RealNumbers
  {
    public static void main(String args[]) {
      x1 = 2.8f;
      x2 = 45.890d;
      float y = 17f;
      double z = 3d;
      double r = y / z;

      System.out.println("y / z = " + r);
    }
  }
\end{lstlisting}
\vspace{1em}

\vspace{1em}
\noindent
In generale non è necessario specificare sempre \quotes{f} o \quotes{d} per \emph{float} o \emph{double}: principalmente si sta specificando quanta memoria utilizzare.

\vspace{1em}
\subsection{Definizione di variabili}
Le variabili di un tipo primitivo si definiscono come nei seguenti esempi:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Dichiarazione di variabili in Java]
  public class DichiarazioneVariabili
  {
    public static void main(String args[]) {
      int n;
      doubled d = 10.0;
      boolean b, bb = true;
      charc c = '\t';
    }
  }
\end{lstlisting}
\vspace{1em}

\noindent
I dati che descrivono un problema si possono suddividere in \textbf{costanti} e \textbf{variabili}:
\begin{itemize}
  \item i dati variabili possono cambiare valore;
  \item i dati costanti sono dati che hanno un valore predefinito, che non cambia. Una costante è una variabile \emph{final} con valore iniziale specificato, come mostrato di seguito. Generalmente il nome della variabile viene specificato in maiuscolo ed è importante che il valore non cambi, specialmente quando ad uno stesso codice sorgente lavorano più programmatori.
\end{itemize}

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Dichiarazione di costanti in Java]
  public class DichiarazioneCostanti
  {
    public static void main(String args[]) {
      final int CNST_1 = 10;
      final int CNST_2 = CNST_1*3;
    }
  }
\end{lstlisting}
\vspace{1em}

\subsection{Espressioni}
Un’espressione è composta da \textbf{operandi} e \textbf{operatori}, e viene calcolata eseguendo in sequenza una serie di operazioni.\\
Per ogni operatore, vengono prima valutati gli operandi e quindi applicato l’operatore stesso. Alcuni operatori richiedono esplicitamente che un operando sia una variabile, mentre l’utilizzo dei delimitatori \quotes{parentesi tonde} individua sottoespressioni che vengono considerate operandi e che quindi vengono calcolate per prime.

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Ordine delle operazioni in Java]
  public class OrdineOperazioni
  {
    public static void main(String args[]) {
      double x;

      double y1 = x / 3 * 2;
      double y2 = (x / 3) * 2;
    }
  }
\end{lstlisting}
\vspace{1em}

\noindent
\textbf{Osservazione}: Gli operatori $/$ e $\ast$ hanno la stessa precedenza, per cui l'ordine di esecuzione viene determinato dall’associatività: gli operatori aritmetici binari sono associativi a sinistra, e l'espressione $x / 3 * 2$ viene calcolata come se fosse scritta $(x / 3) * 2$.

\vspace{1em}
\subsection{Operatore condizionale}
L’operatore condizionale ha la forma:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Operatore condizionale in Java]
  public class OperatoreCondizionale
  {
    public static void main(String args[]) {
      op1 ? op2 : op3;
    }
  }
\end{lstlisting}
\vspace{1em}

\noindent
Tale operatore richiede che il primo operando \emph{op1} sia di tipo booleano: se questo vale \emph{true} il risultato è il valore dell’operando \emph{op2}, altrimenti il valore dell’operando \emph{op3}.

\vspace{1em}
\subsection{Incremento e decremento}
Gli operatori (unari) \quotes{$++$} e \quotes{$--$} richiedono come operando una variabile:
\begin{itemize}
  \item il valore aggiornato della variabile se prefissi;
  \item il valore originario della variabile se postfissi.
\end{itemize}
Quando tali operatori sono prefissi hanno la priorità nell'operazione, mentre se sono postfissi, prima viene eseguita l'operazione e poi dopo l'incremento/decremento, come mostrato di seguito

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Incremento in Java]
  public class Incremento
  {
    public static void main(String args[]) {
      int a = 5;
			System.out.println("Il valore di a e' uguale a" + a++);
			a = 5;
			System.out.println("Il valore di a e' uguale a" + ++a);
    }
  }
\end{lstlisting}
\vspace{1em}

\newpage
\noindent
\begin{center}
  8 Marzo 2022
\end{center}

\subsection{Altri operatori}
Di seguito si espongono ulteriori operatori utili alla programazione in Java

\vspace{1em}
\noindent
\rowcolors{1}{white}{white}
\begin{tabularx}{\textwidth}{|>{\hsize=0.1\textwidth}P|P|}
  \hline
  \rowcolor{blue!5}
  \textbf{Operatore} & \textbf{Descrizione}\\
  \hline
  \textbf{[]} & Definisce un array, come \textbf{char[]}\\
  \hline
  \textbf{.} & Riferisce a un membro di un oggetto\\
  \hline
  \textbf{(tipo)} & \parbox{\linewidth}{\vspace{3mm} Converte, ossia effettua un \textbf{casting} dela variabile alla quale quale è affiancato in base al \emph{tipo} specificato, se il tipo di dato da convertire è compatibile con tale conversione (che non altera il contenuto informativo della variabile, ma solo la sua interpretazione, come numero o carattere, per esempio).
	La conversione deve rispettare una specifica gerarchia e può essere eseguita in modo diretto solamente tra i tipi di dato primitivo. Per i dati derivati è necessario impiegare metodoi opportuni di classi specifiche. Un programma interno alla macchina virtuale, che prende il nome di \textbf{Garbage-Collector}, opera all'interno dell'\textbf{heap} di memoria  dinamica per cercare di ottimizzare lo spazio (come quando si istanza un oggetto senza poi disfarsene al termine del suo utilizzo).\vspace{3mm}}\\
  \hline
  \textbf{new} & \parbox{\linewidth}{\vspace{3mm} Crea un nuovo oggetto e lo alloca in una parte dinamica della memoria dell'elaboratore, chiamata \textbf{heap}, più libera e non controllata dal sistema operativo, che differisce dall'area di memoria più contenuta, ma più veloce, riservata alle variabili primitive, chiamata \textbf{stack}, maggiormanete controllata dal sistema operativo. \vspace{3mm}}\\
  \hline
  \textbf{instanceof} & \parbox{\linewidth}{\vspace{3mm}restituisce \emph{true} se $op1$ è una istanza di $op2$, come nel caso di $op1$ $instanceof$  $op2$\vspace{3mm}}\\
  \hline
\end{tabularx}

\vspace{1em}
\subsection{Casting - Conversione di tipo}
Una conversione di tipo consente:
\begin{itemize}
  \item nel caso di un \textbf{operatore aritmetico binario}, di trasformare il tipo di un operando nel tipo dell’altro operando;
  \item nel caso dell’\textbf{operatore di assegnazione}, di trasformare il tipo del risultato di una espressione nel tipo della variabile a cui il nuovo valore deve essere assegnato;
  \item nell’ambito dei tipi “integral” e “floating”, rispettivamente, verso il tipo che \textbf{usa un maggior numero di bit per la rappresentazione}, con nessuna perdita di informazione.
\end{itemize}

\vspace{1em}
\subsection{Classe Math}
La classe \textbf{Math} fa parte del package \textbf{java.lang}, contiene come \textbf{membri statici} (per cui non c'è bisogno di istanziare un nuovo oggetto Math con \textbf{new} per accedervi) alcune \emph{costanti} e diverse \emph{funzioni matematiche} di uso comune, come il valore assoluto, la radice $n$-esima, operazioni trigonometriche, arrotondamento, etc.

\vspace{1em}
\subsection{Classe String}
Una \textbf{stringa} è una sequenza di caratteri, che può anche non avere alcun carattere (\textbf{stringa vuota}). Una variabile appartenente a questo tipo, detta variabile stringa, rappresenta il riferimento di un oggetto stringa che memorizza una stringa costante.

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Inizializzazione di una stringa in Java]
  public class ClasseStringa
  {
    public static void main(String args[]) {
      // Inizializzazione della stringa primaStringa con il parametro "Ciao mondo!"
      String primaStringa = new String("Ciao mondo!");
    }
  }
\end{lstlisting}
\vspace{1em}

\noindent
All'interno della inizializzazione è presente il metodo costruttore \textbf{new String()} che permette di istanziare un oggetto della classe String specificata, allocandovi uno spazio di memoria nell'heap di memoria.\\
La classe \textbf{String} è una classe le cui istanze rappresentano dellle stringhe di caratteri alfanumerici. Tutte le stringhe nei programmi Java, come \quotes{abc}, vengono implementate come istanze della classe \emph{String}.

\vspace{1em}
\subsection{Classe Integer}
La classe \textbf{Integer} consente di creare un oggetto classe a partire da un valore del tipo primitivo \textbf{int}: pertanto la classe \emph{Integer} è è un \textbf{wrapper}: le classi wrapper sono predefinite nel linguaggio e servono a racchiudere in oggetti i valori di un tipo primitivo al fine di ottimizzarne i metodi e la manipolazione, come mostrato di seguito:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Classe Integer in Java]
  public class ClasseInteger
  {
    public static void main(String args[]) {
      // Istanza di un Integer senza new, ma direttamente attraverso il metodo
      // della classe Integer
      Integer numero = Integer.parseInt("300");
      System.out.println(numero * 2);
    }
  }
\end{lstlisting}
\vspace{1em}

\noindent
Altri esempi di classi wrapper sono
\begin{enumerate}
  \item Boolean
  \item Byte
  \item Character
  \item Integer
  \item Long
  \item Float
  \item Double
\end{enumerate}

\vspace{1em}
\subsection{Classe Console}
All'interno della classe \textbf{Console} sono presenti le funzioni atte ad effettuare una emulazione dell'ambiente di linea di comando al fine di effettuare \textbf{letture da tastiera e scritture su video} di valori appartenenti ai principali tipi di dato primitivo (tipi boolean, char, int, double) e al tipo stringa (String).\\
Tale classe è estremamemente utile per ottimizzare il codice, facilitando l'interazione con l'utente, e renderlo versatile, ossia capace di adattarsi a diversi tipi di input e output che possono derivare dell'esecuzione del programma.\\
I programmi Java, infatti, possono utilizzare classi predefinite, ma anche e soprattuto facenti parte di un \textbf{package} esterno, tipicamente dei package che costituiscono le \textbf{Java API}, attraverso la loro importazione, come nel caso della libreria \textbf{java.io.Console} mostrata di seguito:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Classe Console in Java]
  import java.io.Console;

  public class ClasseConsole
  {
    public static void main(String args[]) {
      Console console = System.console(); // Inizializzazione oggetto Console

      System.out.println("Inserisci il primo numero:");
      String input = console.readLine();  // Lettura dato da tastiera
      int pNum = Integer.parseInt(input); // Conversione in intero del dato letto
      System.out.println("Il primo numero e': " + pNum);

      System.out.println("Inserisci il secondo numero:");
      input = console.readLine();         // Lettura dato da tastiera
      int sNum = Integer.parseInt(input); // Conversione in intero del dato letto
      System.out.println("Il primo numero e': " + sNum);

      System.out.println("La somma tra i due numeri e': " + (pNum+sNum));
    }
  }
\end{lstlisting}

\newpage
\noindent
\begin{center}
  14 Marzo 2022
\end{center}
In Java esistono $3$ principali tipi di input
\begin{itemize}
  \item System.in (java.lang.System);
  \item String[] args, tramite il terminale;
  \item Console (java.io.Console);
  \item Scanner (java.util.Scanner);
\end{itemize}

\vspace{1em}
\subsection{Classe Scanner}
La \textbf{lettura formattata} di valori di un tipo primitivo (escluso il tipo byte) o di tipo stringa, si effettuano comunemente utilizzando stream appartenenti alla classe \textbf{Scanner}.\\
La classe Scanner presenta diverse funzionalità:
\begin{itemize}
  \item Lettura della \textbf{password} senza fare eco ai caratteri inseriti.
  \item I metodi di lettura \textbf{sono sincronizzati}.
  \item È possibile utilizzare la \textbf{sintassi della stringa di formato}.
  \item Non funziona in un ambiente non interattivo (come in un IDE).
\end{itemize}
A differenza della classe Console, la quale
\begin{itemize}
  \item presenta metodi convenienti per analizzare le primitive (nextInt(), nextFloat(), ...).
  \item presenta metodi di lettura \textbf{non sincronizzati}.
\end{itemize}
Per impiegare la classe Scanner è necessario procedere all'importazione della libreria \textbf{java.util.Scanner}:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Classe Scanner in Java]
  import java.io.Console;
  import java.util.Scanner;

  public class ClasseScanner
  {
    public static void main(String args[]) {
      Console console = System.console();     // Inizializzazione oggetto Console
      Scanner sc = new Scanner(con.reader()); // Inizializzazione oggetto Scanner

      con.printf("****************************\n");
      con.printf("Un altro programma! \n");
      con.printf("****************************\n");

      con.printf("Qual e' il tuo nome? \n >>>");
      String nome = sc.nextLine();                 // Lettura dato da tastiera

      con.printf("Ciao " + nome + "! Quanti anni hai? \n >>>");
      int anni = Integer.parseInt(sc.nextLine());  // Lettura dato da tastiera

      con.printf("Ok, grazie dell'informazione!");
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
In cui è noto che \textbf{Integer} è un \textbf{wrapper}, ossia una classe che ingloba il tipo di dato primitivo \textbf{int} e ne amplia l'utilizzo, grazie a nuovi metodi complessi e l'utilizzo di memoria dinamica.\\
È possibile, tramite la classe Scanner, impiegare metodi per analizzare le primitive (nextInt(), nextFloat(), ...), come mostrato di seguito:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Calcolo Indice Massa Corporea in Java]
  import java.io.Console;
  import java.util.Scanner;

  public class IMC
  {
    public static void main(String args[]) {
      Console console = System.console();     // Inizializzazione oggetto Console
      Scanner sc = new Scanner(con.reader()); // Inizializzazione oggetto Scanner

      con.printf("****************************\n");
      con.printf("Calcolo - Indice Massa Corporea (IMC)");
      con.printf("****************************\n");

      con.printf("Altezza: \n >>>");
      double altezza = sc.nextDouble();// Lettura dato da tastiera

      con.printf("Peso: \n >>>");
      int altezza = sc.nextInt();      // Lettura dato da tastiera

      con.printf("IMC = %.2f", (peso / (altezza*altezza)));
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
In cui \quotes{\%.2f} specifica il formato con due cifre decimali.

\vspace{1em}
\subsection{Classi e Oggetti}
I \textbf{tipi primitivi} prevedono la definizione di \textbf{variabili} di un dato tipo; com'è noto, una variabile di un tipo primitivo ha un nome e un valore e il tempo di vita di una tale variabile \textbf{dipende dal luogo in cui è definita} (per esempio, le variabili definite nel corpo di una funzione sono automatiche).\\
Per esempio, un oggetto \textbf{Stringa} viene creato (e allocato in memoria dinamica \textbf{heap}) per mezzo dell’operatore \emph{new} seguito da un \textbf{costruttore}.\\
Il recupero della \textbf{memoria dinamica} non più utilizzata viene effettuata dalla piattaforma \textbf{Java} per mezzo di una specifica routine (chiamata \textbf{Garbage Collector}), che periodicamente libera quelle zone di memoria della macchina virtuale occupate da oggetti per i quali non esiste più alcuna variabile/oggetto che li riferisce.\\
Pertanto, mentre per le variabili di tipo primitivo è il sistema a gestirne l'allocazione, per gli oggetti, istanze di opportune classi, è il programmatore a dover fare un buon uso della memoria, coadiuvato dal programma \textbf{Garbage Collector}.

\newpage
\section{Istruzioni in Java}
Di seguito si espongono le principali istruzioni in linguaggio Java, che permettono di strutturare in maniera più complessa il programma:
\begin{itemize}
  \item Istruzioni codizionali
  \item Istruzioni ripetitive
  \item Istruzioni di salto
\end{itemize}

\vspace{1em}
\subsection{Istruzioni condizionali}
Si consideri il seguente codice sorgente Java:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Esempio dell'istruzione condizionale if in Java]
  import java.io.Console;
  import java.util.Scanner;

  public class IMC2
  {
    public static void main(String args[]) {
      Console console = System.console();     // Inizializzazione oggetto Console
      Scanner sc = new Scanner(con.reader()); // Inizializzazione oggetto Scanner

      con.printf("****************************\n");
      con.printf("Calcolo - Indice Massa Corporea (IMC) (V2)");
      con.printf("****************************\n");

      con.printf("Altezza: \n >>>");
      double altezza = sc.nextDouble(); // Lettura dato da tastiera

      con.printf("Peso: \n >>>");
      int altezza = sc.nextInt();       // Lettura dato da tastiera

      float imc = (peso / (float)(altezza*altezza));
      con.printf("Il tuo IMC e' %.2f, questo significa che sei ", IMC);

      if(imc<16)
        con.printf("sottopeso grave\n");
      else if(imc<18.8)
        con.printf("sottopeso\n");
      else if(imc<25)
        con.printf("normale\n");
      else if(imc<30)
        con.printf("sovrappeso\n");
      else
        con.printf("obeso\n");
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
Come si può notare, le \textbf{istruzioni condizionali} comprendono l’istruzione \textbf{if} e l’istruzione \textbf{switch}. La \textbf{condizione} è un’espressione che deve produrre un risultato di tipo \textbf{booleano} (notare che non è possibile nessuna conversione di tipo fra intero e booleano, né implicita né indicata esplicitamente dal programmatore).
Da notare che la parte \textbf{else} può anche mancare, per cui se la condizione è vera, viene eseguita l’istruzione che segue \textbf{if}, altrimenti quella che segue \textbf{else} (se presente).

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=2cm]
    % start
    \tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
    % input/output
    \tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
    % process
    \tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]

    % if
    \tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
    % arrow
    \tikzstyle{arrow} = [thick,->,>=stealth]

    \node (start) [startstop] {Inzio};
    \node (dec1)  [decision, below of=start, yshift=-4em] {Condizione};
    \node (istV)  [process, right of=dec1, xshift=8em] {Istruzione se vero};
    \node (istF)  [process, left of=dec1, xshift=-8em] {Istruzione se falso};
    \node (end)   [startstop, below of=start, yshift=-14em] {Fine};

    \draw [arrow] (start) -- (dec1);
    \draw [arrow] (dec1) -- node[midway, above]{vero}  (istV);
    \draw [arrow] (dec1) -- node[midway, above]{falso} (istF);
    \draw [arrow] (istV) |- (end);
    \draw [arrow] (istF) |- (end);
  \end{tikzpicture}
  \caption{Diagramma di flusso con istruzione condizionale}
  \label{fig:diagramma_flusso_istruzione_condizionale}
\end{figure}

\vspace{1em}
\noindent
Naturalmente, è possibile anche concatenare fra di loro diverse istruzioni condizionali, come mostrato di seguito:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Calcolo delle radici in Java]
  public class Radici
  {
    public static void main(String args[]) {
      double a,b,c,delta;
      a = Float.parseFloat(args[0]);
      b = Float.parseFloat(args[1]);
      c = Float.parseFloat(args[2]);

      if(a==0 && b==0)
        System.out.println("Equazione degenere");
      else if(a==0) {
        System.out.println("Equazione di primo grado");
        System.out.println(-c/b);
      } else {
        delta = b*b - 4*a*c;
        if(delta<0)
          System.out.println("Determinante negativo!");
        else {
          delta = Math.sqrt(delta);
          System.out.println("Equazione di secondo grado");
          System.out.println((-b+delta)/(2a));
          System.out.println((-b-delta)/(2a));
        }
      }
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
In cui, naturalmente, se non vengono poste delle partesi graffe per delmitare lo \emph{scope} dell'istruzione condizionale significa implicitamente che lo \emph{scope} è costituito da una sola riga di codice.

\vspace{1em}
\noindent
Usando l'istruzione \textbf{switch}, la condizione deve essere un'espressione di tipo \emph{byte}, \emph{char}, \emph{short} o \emph{int}, ed ogni espressione costante (\emph{constant-expression}), valutata durante la compilazione.\\
La sequenza di istruzioni contenute nell’alternativa selezionata viene quindi eseguita con la seguente logica:
\begin{itemize}
  \item l'ultima istruzione della sequenza deve produrre la terminazione dell’istruzione \textbf{switch}.
  \item tale terminazione può essere ottenuta con un'istruzione \textbf{break}. Se tale istruzione viene a mancare, verranno eseguiti tutti i case sottostanti, fino a che non viene incontrato un \textbf{break}.
\end{itemize}

\vspace{1em}
\noindent
Si consideri l'esempio seguente:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Esempio dell'istruzione condizionale switch in Java]
  public class NumeroPari
  {
    public static void main(String args[]) {
      int numero = Integer.parseInt(args[0]);
      switch(numero%2){
        case 0:
          System.out.println("Il numero " + numero + " e' pari");
        break;

        default:
          System.out.println("Il numero " + numero + " e' dispari");
        break;
      }
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Osservazione}: Si osservi che è anche possibile ripetere uno stesso \textbf{case} più volte, ma verrà sempre eseguito il primo per ordine di precedenza.\\
Inoltre si possono raggruppare anche più \textbf{case} insieme, come mostrato di seguito:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Esempio di multiple-case switch in Java]
public class NumeroPari
{
  public static void main(String args[]) {
    int numero = Integer.parseInt(args[0]);
    switch(numero){
      case 0: case 2: case 4: case 6: case 8: case 10:
        System.out.println("Il numero " + numero + " e' pari");
      break;

      case 1: case 3: case 5:
      System.exit(1);

      default:
        System.out.println("Il numero " + numero + " e' dispari");
      break;
    }
  }
}
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Osservazione}: Si osservi che l'istruzione \textbf{System.exit(1)} permette di terminare l'esecuzione del programma corrente (esattamente come l'istruzione \textbf{return}).

\newpage
\noindent
\begin{center}
  15 Marzo 2022
\end{center}
\subsection{Istruzioni ripetitive}
Le \textbf{istruzioni ripetitive} comprendono l’istruzione \emph{while}, l’istruzione \emph{do-while} e l’istruzione \emph{for}:
\begin{itemize}
  \item \textbf{While}: La \textbf{condizione viene valutata come prima istruzione} ed è un’espressione che deve produrre un risultato di tipo booleano. Se la condizione è vera, viene eseguita l’istruzione che costituisce il corpo del costrutto e l’istruzione while viene ripetuta, altrimenti l’istruzione while termina.

  \item \textbf{Do-While}: La \textbf{condizione viene valutata dopo} che è stata eseguita l’istruzione che costituisce il corpo del costrutto, e, se vera, l’istruzione do-while viene ripetuta.

  \item \textbf{For}: L'inizializzazione è un’espressione di assegnamento che inizializza una variabile di controllo (eventualmente con definizione di tale variabile), e l’aggiornamento (o passo) è un’espressione che dà un nuovo valore alla variabile di controllo stessa (la incrementa o la decrementa, generalmente).
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=2cm]
    % start
    \tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
    % input/output
    \tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
    % process
    \tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]

    % if
    \tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
    % arrow
    \tikzstyle{arrow} = [thick,->,>=stealth]

    \node (start) [startstop] {Inzio};
    \node (dec1)  [decision, below of=start, yshift=-4em] {Condizione};
    \node (istV)  [process, right of=dec1, xshift=8em] {Istruzione se vero};
    \node (end)   [startstop, below of=start, yshift=-14em] {Fine};

    \draw [arrow] (start) -- (dec1);
    \draw [arrow] (dec1) -- node[midway, above]{vero} (istV) -- ++(2,0) -- ++(0,2) -| (dec1);
    \draw [arrow] (dec1) -- node[midway, right]{falso} (end);
  \end{tikzpicture}
  \caption{Diagramma di flusso con istruzione ripetitiva}
  \label{fig:diagramma_flusso_istruzione_ripetitiva}
\end{figure}

\vspace{0.1em}
\noindent
\textbf{Esempio}: Si espone di seguito un programma che mostra un primo utilizzo dell'istruzione ripetitiva \textbf{while}:

\vspace{0.3em}
\noindent
\begin{lstlisting}[language=Java, caption=Istruzione ripetitiva while in Java]
  public class MCD
  {
    public static void main(String args[]) {
      int alfa,beta,mcd;
      alfa = Integer.parseInt(args[0]);
      beta = Integer.parseInt(args[1]);

      while(alfa != beta) {
        System.out.println(":alfa"+alfa);
        System.out.println(":beta"+beta);
        if(alfa > beta)
          alfa -= beta;
        else
          beta -= alfa;
      }
      mcd = alfa;
      System.out.println("**************** MCD:"+mcd);
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Esempio}: Si espone di seguito un programma che mostra un primo utilizzo dell'istruzione ripetitiva \textbf{do-while}:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Istruzione ripetitiva do-while in Java]
  import java.io.Console;
  import java.util.Scanner;

  public class InputPari
  {
    public static void main(String args[]) {
      int c;

      Console con = System.console();
      Scanner sc = new Scanner(con.reader());

      do{
        con.printf("Immettere un numero pari:");
        c = Integer.parseInt(sc.next());
        System.out.println(":beta"+beta);
      }while(c%2!=0);
      mcd = alfa;
      con.printf("Grazie!\n");
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Esempio}: Si espone di seguito un programma che mostra un primo utilizzo dell'istruzione ripetitiva \textbf{do-while}:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Istruzione ripetitiva for in Java]
  public class Fatt
  {
    public static void main(String args[]) {
      int num, fattoriale=1;
      num = Integer.parseInt(args[0]);

      for(int i=1;i<=num;i++){
        fattoriale*=i;
        System.out.println(fattoriale);
      }
      System.out.println(fattoriale);
    }
  }
\end{lstlisting}

\vspace{1em}
\subsection{Istruzioni di salto}
Un'\textbf{istruzione di salto} cambia il flusso di ripetizioni di esecuzioni dei codice. Le istruzioni di salto sono le seguenti:
\begin{itemize}
  \item Istruzione \textbf{break}: Se l’identificatore viene inserito, esso produce la terminazione del costrutto \textbf{switch}, \textbf{while}, \textbf{do-while} o \textbf{for} in cui compare;
  \item Istruzione \textbf{continue}: Se l’identificatore viene inserito, esso produce la terminazione della iterazione corrente del ciclo \textbf{while}, \textbf{do-while} o \textbf{for} in cui compare, con esecuzione della iterazione successiva;
  \item Istruzione \textbf{return}: Essa produce la terminazione della funzione in cui compare.
\end{itemize}

\newpage
\noindent
\textbf{Esempio}: Si espone di seguito un programma che mostra un primo utilizzo dell'istruzione di salto \textbf{break}:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Istruzione di salto break in Java]
  public class EsempioBreak
  {
    public static void main(String args[]) {
      for(int i=1;i<=10;i++){
        System.out.println("i:"+i);
        if(i==5) break;
      }
      System.out.println("Fine!");
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Esempio}: Si espone di seguito un programma che mostra un primo utilizzo dell'istruzione di salto \textbf{continue}:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Istruzione di salto continue in Java]
  public class EsempioContinue
  {
    public static void main(String args[]) {
      for(int i=1;i<=10;i++){
        if(i==5) continue;
        System.out.println("i:"+i);
      }
      System.out.println("Fine!");
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Esempio}: Si espone di seguito un programma che mostra un primo utilizzo dell'istruzione di salto \textbf{return}:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Istruzione di salto return in Java]
  public class EsempioReturn
  {
    public static void main(String args[]) {
      for(int i=1;i<=10;i++){
        System.out.println("i:"+i);
        if(i==5) return;
      }
      System.out.println("Fine!");
    }
  }
\end{lstlisting}

\newpage
\begin{center}
  21 Marzo 2022
\end{center}
\section{Array}
Com'è noto, in Java esistono \textbf{tipi di dato primitivi}, i quali prevedono la definizione di variabili di un dato tipo, ove per variabile di tipo primitivo è da intendersi una locazione di memoria nello \textbf{stack} avente un \textbf{nome} e un \textbf{valore}; il \textbf{tempo di vita} di una variabile dipende dal luogo (\emph{scope}) in cui è definita.\\
I \textbf{tipi derivati} (enumerazioni, array, stringhe, ecc) prevedono la definizione del tipo, la definizione di variabili di quel tipo e la creazione di oggetti di quel tipo: un tipo derivato è costituito da più componenti (anche una sola) raggruppate in un’unica entità; una variabile di un tipo derivato ha le stesse caratteristiche di una variabile di un tipo primitivo, con la differenza che il suo valore è un indirizzo, quello di un oggetto di quel tipo. Un oggetto di un tipo derivato ha un tempo di vita dinamico: viene creato esplicitamente quando serve (per mezzo dell’operatore new), allocato in una zona di memoria, detta, appunto, \textbf{memoria dinamica} (o \textbf{heap}).

\vspace{1em}
\subsection{Enumerazione}
I tipi \textbf{enumerazione} vengono usati per rappresentare un numero limitato di valori associati a informazioni non numeriche, per cui gli enumeratori sono identificatori di costanti e gli oggetti riferiti dagli enumeratori vengono creati implicitamente nel momento in cui viene definito il tipo.

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Enumerazione in Java]
  public class Semaforo
  {
    public static void main(String args[]) {
      enum SemaforoEnum {verde,giallo,rosso};
      SemaforoEnum attuale = SemaforoEnum.verde;
      System.out.println("Il valore attuale e': "+attuale);
      for(SemaforoEnum i : SemaforoEnum.values())
        System.out.println(i);
    }
  }
\end{lstlisting}

\vspace{1em}
\subsection{Array monodimensionale}
Il tipo di dato \textbf{aray} rappresenta un \textbf{aggregato} di elementi di uno \textbf{stesso tipo}: ogni elemento si accede mediante un indice che ne individua la posizione (un numero intero positivo $n$ di elementi, il cui indice va da $0$ a $n-1$); gli elementi di un array vengono selezionati per mezzo dell’operatore di indicizzazione \quotes{[]}.

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Esempio di array in Java]
  public class EsempioArray
  {
    public static void main(String args[]) {
      int[] numArray1 = new int[5]; // Dichiarazione e inizializzazione dell'array
      int[] numArray2[];            // Dichiarazione dell'array
      int numArray3 = {1,2,3,4,5};  // Dichiarazione e inizializzazione dell'array

      numArray1[1] = 300;           // Modifica di un valore dell'array
      numArray2 = new int[100];     // Allocazione dell'array

      System.out.println(numArray1[1]);
      System.out.println(numArray2[99]);
      System.out.println(numArray3[0]);
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
L’\textbf{operatore di assegnamento} (=) può essere applicato anche a variabili array dello stesso tipo: vengono però coinvolti i riferimenti, e non gli oggetti array, come mostrato di seguito:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Operazioni di assegnamento tra array in Java]
  public class EsempioArray2
  {
    public static void main(String args[]) {
      int[] numArray1 = {1,2,3,4}; // Dichiarazione e inizializzazione dell'array
      int[] numArray2[];           // Dichiarazione dell'array

      numArray2 = numArray1;
      System.out.println("numArray1:"+numArray1[0]);
      System.out.println("numArray2:"+numArray2[0]);

      numArray2[0] = 256;
      System.out.println("numArray1:"+numArray1[0]);
      System.out.println("numArray2:"+numArray2[0]);
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
In cui \emph{numArray1} e \emph{numArray2} puntano alla stessa locazione di memoria: ogni modifica che riguarda uno dei due array viene riflesso anche nell'altro.\\
Per avere una copia dell'array e del suo contenuto e non solo dell'indirizzo di memoria bisogna impiegare il metodo \textbf{System.arraycopy(arr1,pStartOrig,arr2,pStartDest,len)}, in cui
\begin{itemize}
  \item \emph{arr1}: è l'array di origine;
  \item \emph{pStartOrig}: è la posizione iniziale nell'array di origine;
  \item \emph{arr2}: è l'array di destinazione;
  \item \emph{pStartDest}: è la posizione iniziale nei dati di destinazione;
  \item \emph{len}: è il numero di elementi dell'array da copiare.
\end{itemize}

\vspace{1em}
\subsection{Array multidimensionale}
Un oggetto array (\textbf{array primario}) può avere come elementi altri oggetti array (\textbf{array secondari}): in questo caso negli elementi dell’array primario sono memorizzati i riferimenti degli array secondari (e non direttamente gli array secondari), come mostrato di seguito:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Array multidimensionale in Java]
  public class EsempioArray2D
  {
    public static void main(String args[]) {
      int[][] numArray2D = {{1,2,3,4}, {5,6}, {7}}; // Array bidimensionale

      for(int i=0;i<numArray2D.length;i++){
        for(int j=0;j<numArray2D[i].length;j++)
          System.out.println("["+i+"]["+j+"]:"+numArray2D[i][j]);
      }
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Osservazione}: Per ricercare se un dato elemento è presente all’interno di un array, ed eventualmente conoscerne la posizione, occorre precisare se l’array è o meno ordinato: se l’array non è ordinato, non si può fare altro che una ricerca completa, come esposto di seguito:

\newpage
\noindent
\begin{lstlisting}[language=Java, caption=Array multidimensionale in Java]
  public class RicercaArray2D
  {
    public static void main(String args[]) {
      int[][] numArray2D = new int[3][4]; // Inizializzazione array a 0

      numArray2D[1][3]=1;
      for(int i=0;i<numArray2D.length;i++){
        for(int j=0;j<numArray2D[i].length;j++)
          if(numArray2D[i][j]!=0)
            System.out.println("Found numArray2D["+i+"]["+j+"]:"+numArray2D[i][j]);
      }
    }
  }
\end{lstlisting}

\newpage
\section{Stringa}
Una stringa è una \emph{sequenza di caratteri}, che può anche non avere alcun carattere (stringa vuota); in Java esiste come classe il tipo String (package java.lang): una variabile appartenente a questo tipo, detta variabile stringa, rappresenta il riferimento di un oggetto stringa.\\
Un oggetto stringa viene creato (e allocato in memoria dinamica) per mezzo dell’operatore \textbf{new} seguito da un costruttore:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Esempio dichiarazione stringa in Java]
  public class DichiarazioneStringa
  {
    public static void main(String args[]) {
      String str1 = "Prima stringa";
      String str2 = new String();
      str2 = "Seconda stringa";
      String str3 = new String("Terza stringa");

      System.out.println(str1);
      System.out.println(str2);
      System.out.println(str2);
    }
  }
\end{lstlisting}

\vspace{1em}
\subsection{Concatenazione}
La concatenazione di stringhe avviene tramite l'operatore $+$:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Dichiarazione di una stringa in Java]
  public class DichiarazioneStringa
  {
    public static void main(String args[]) {
      String str1 = new String("ABC");
      String str2 = new String("DEF");
      String conc = str1+str2;
      System.out.println(conc);

      conc+=100+"";
      System.out.println(conc);
    }
  }
\end{lstlisting}

\vspace{1em}
\subsection{Lunghezza}
La lunghezza di una stringa è determinata dal valore restituito dalla funzione \textbf{length()}, la quale è più propriamente un metodo della classe \textbf{String}:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Lunghezza di una stringa in Java]
  public class LunghezzaStringa
  {
    public static void main(String args[]) {
      String str1 = new String("Ciao mondo!");
      System.out.println("La lunghezza della stringa str1 e'"+str1.length);
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
Anche gli array presentano una propria lunghezza, la quale, però, non cosituisce un metodo di una classe precisa, ma rappresenta un attributo dell'array stesso, per cui si può richiamare come \textbf{arr.length}.

\newpage
\subsection{Uguaglianza}
Per confrontare le stringhe memorizzate in due oggetti stringa si utilizza la funzione \textbf{equals()};

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Uguaglianza fra stringhe in Java]
  public class ConfrontaStringhe
  {
    public static void main(String args[]) {
      String str1 = "Italia";
      String str2 = "Italia";
      String str3 = "Brasile";

      System.out.println(str1==str2);
      System.out.println(str1.equals(str2));

      System.out.println(str1==str3);
      System.out.println(str1.equals(str3));
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Osservazione}: La ragione della differenza tra $==$ e \emph{equals} è dovuta al fatto che $==$ confronta l'indirizzo di memoria di due stringhe che è, ovviamente, differente, mentre \emph{equals} confronta il contenuto memorizzato all'interno delle stringhe che può essere anche uguale.

\vspace{1em}
\subsection{Selezione di un carattere}
Per conoscere il carattere di una stringa ad una specifica posizione bisogna impiegare la funzione \textbf{charAt()}:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Uguaglianza fra stringhe in Java]
  public class CarattereStringa
  {
    public static void main(String args[]) {
      String str1 = "123456789";
      System.out.println("Il sesto carattere di "+str1+" e': " + str1.charAt(6));
    }
  }
\end{lstlisting}

\vspace{1em}
\subsection{Confronto}
Le stringhe memorizzate in due oggetti stringa possono essere confrontate fra loro (lessicograficamente) per mezzo della funzione compareTo().\\
Il risultato del confronto è
\begin{itemize}
  \item negativo, se la prima stringa è più corta della seconda (e il valore di ritorno specifica il numero di caratteri di differenza);
  \item positivo, se la prima stringa è più lunga della seconda (e il valore di ritorno specifica il numero di caratteri di differenza);
  \item zero, se la prima stringa è uguale alla seconda.
\end{itemize}

\newpage
\noindent
\begin{lstlisting}[language=Java, caption=Confronto fra stringhe in Java]
  public class ConfrontoStringhe
  {
    public static void main(String args[]) {
      String strP = "abc";
      String strM = "abcd";
      String strL = "abcdef";

      System.out.println(strP.compareTo(strM));
      System.out.println(strP.compareTo(strL));
      System.out.println(strL.compareTo(strM));
      System.out.println(strL.compareTo(strP));
      System.out.println(strP.compareTo("123"));
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Osservazione}: Si osservi che, generalmente, per deteminare il risultato del confronto tra stringhe, si converte ciascun carattere secondo la tabella ASCII e si esegue la differenza fra i valori ottenuti: il risultato è proprio l'esito di tale operazione di differenza, come nell'ultimo caso sopra descritto, in cui il risultato della comparazione è $48$ in quanto la differenza tra ciascun carattere alfanumerico è $48$, secondo la tabella ASCII.

\newpage
\noindent
\begin{center}
  22 Marzo 2022
\end{center}
\section{Funzioni in Java}
Com'è noto, la classe principale di un programma è la funzione \emph{main()}; tuttavia, è possibile creare delle nuove funzioni che saranno richiamata dalla funzione \emph{main()} o da altre classi.\\
Nella definizione di una funzione occorre indicare:
\begin{itemize}
  \item il modificatore di visibilità;
  \item il tipo di istanziazione (static o meno);
  \item il tipo di ritorno;
  \item il nome;
  \item eventuali parametri in ingresso;
  \item le istruzioni da eseguire
\end{itemize}

\vspace{1em}
\noindent
\textbf{Osservazione}: Si osservi che metodo \emph{Java main()} è sempre statico, in modo tale che il compilatore possa richiamarlo senza la creazione di un oggetto o prima della creazione di un oggetto della classe.

\vspace{1em}
\subsection{Struttura}
Il corpo di una funzione (essendo un blocco) non può contenere altre definizioni di funzione, ma solo definizioni di:
\begin{itemize}
  \item variabili;
  \item classi.
\end{itemize}
Una funzione può restituire come valore un risultato, oppure non avere nessun risultato (in tale caso verrà specificato il tipo di ritorno tramite la parola chiave \textbf{void}); il corpo, inoltre, deve prevedere almeno una istruzione \textbf{return}, con la specifica dell’espressione il cui valore rappresenta il risultato stesso.

\vspace{1em}
\subsection{Visibilità}
Le funzioni, come le stesse variabili, possono presentare differenti visibilità:
\begin{itemize}
  \item \textbf{public}: sono accessibili sia dall’interno che dall’esterno della classe;
  \item \textbf{protected}: possono essere utilizzate all’interno della classe stessa e all’interno delle classi derivate;
  \item \textbf{private}: possono essere utilizzate soltanto all’interno della classe stessa.
  \item \textbf{default} (ossia senza specificazione): sono accessibili solo da tutte le classi nel medesimo package.
\end{itemize}

\vspace{1em}
\noindent
Si ricordi che lo \emph{scope} di una variabile rappresenta l’area di codice nella quale un identificatore resta associato ad un indirizzo di memoria: ogni blocco (cioè ogni gruppo di linee di codice racchiuso tra parentesi graffe) definisce uno \emph{scope} e ogni variabile locale ha come scope l’area di codice che inizia dalla definizione della variabile stessa e termina con il blocco corrente.\\
In Java, a tal proposito, si distinguono quattro tipi di variabili:
\begin{itemize}
  \item \textbf{variabili locali}: valide solamente all’interno di un metodo, di un ciclo, etc.;
  \item \textbf{variabili di istanza o globali}: variabili dichiarate all’esterno di ogni metodo e quindi visibili da ciascuna funzione;
  \item \textbf{variabili di classe}: variabili \textbf{static} di una classe che possono essere impiegate senza istanziare un oggetto della classe stessa; tali variabili sono condivise da tutte le istanze della classe, in quanto per le variabili statiche esiste \textbf{un'unica locazione di memoria};
  \item \textbf{variabili static + final}: sono costanti di classe; infatti tramite il modificatore \textbf{final} è possibile specificare che una variabile viene inizializzata una sola volta;
\end{itemize}

\vspace{1em}
\subsection{Overloading}
Si osservi che funzioni differenti possono avere lo \textbf{stesso identificatore} (\emph{sovrapposizione} o \emph{overloading}): esse devono, però, avere una differente firma (\emph{signature}):
\begin{itemize}
  \item parametri formali differenti in numero;
  \item e/o tipo;
  \item e/o ordine.
\end{itemize}
Si consideri l'esempio seguente:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Overloading in Java]
  public class Overloading
  {
    public static final double PI = 3.141592;

    public static void main(String args[]) {
      double raggio = Double.parseDouble(args[0]);

      System.out.println("Il volume della sfera e': "+vSfera(raggio));
      System.out.println("Il volume della sfera e': "+vSfera(args[0]);
    }

    public static double vSfera(double raggio){
      return (4/3 * PI * raggio * raggio * raggio);
    }

    public static double vSfera(int raggio){
      return (4/3 * PI * raggio * raggio * raggio);
    }

    public static double volumeSphera(String str){
      double raggio = Double.parseDouble(str);
      return (4/3 * PI * raggio * raggio * raggio);
    }

  }
\end{lstlisting}

\vspace{1em}
\subsection{Ricorsione}
Una funzione può invocare non solo un’altra funzione, ma anche se stessa: in questo caso si dice che la funzione è \textbf{ricorsiva} (ovvero si ha una nuova istanza della medesima funzione mentre l’istanza attuale non è ancora conclusa).
Un classico esempio è quello del calcolo del fattoriale di un numero intero positivo $n$, che può essere espresso ricorsivamente nel seguente modo:

\newpage
\noindent
\begin{lstlisting}[language=Java, caption=Funzione ricorsiva in Java]
  public class Fattoriale
  {
    public static void main(String args[]) {
      int n = Integer.parseInt(args[0]);

      System.out.println("Il fattoriale di "+n+" e': "+fact(n));
    }

    public int fact(int n){
      if(n==0) return 1;
      return n*fact(n-1);
    }
  }
\end{lstlisting}

\newpage
\noindent
\begin{center}
  4 Aprile 2022
\end{center}
\section{Classi e Oggetti}
Una classe è un \textbf{modello} che \textbf{descrive} una certa categoria di oggetti. Essa comprende un certo numero di membri:
\begin{itemize}
  \item variabili membro o campi dati;
  \item funzioni membro o metodi;
  \item costruttori (metodo chiamato per la creazione degli oggetti);
\end{itemize}
come viene mostrato nell'esempio seguente:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Esempio di classe Java]
  class MiaClasse   // Dichiarazione della classe
  {
    int n;          // Dichiarazione della variabile

    MiaClasse(){    // Dichiarazione del costruttore
      /* ... */
    }

    int fai(int a){ // Dichiarazione del metodo
      /* .. */
    }
  }
\end{lstlisting}

\vspace{1em}
\noindent
Una variabile di un tipo classe (brevemente chiamata \textbf{variabile classe}) è un riferimento di oggetto di quella classe.\\
Un oggetto di un tipo classe (brevemente chiamato \textbf{oggetto classe}) è un’istanza della classe (oggetto istanza): viene ottenuto per mezzo dell’operatore \textbf{new}:

\vspace{1em}
\noindent
\begin{lstlisting}[language=Java, caption=Esempio variabile e oggetto di classe Java]
  MiaClasse varA;                   // Variabile di tipo classe non istanziata
  varA = new MiaClasse();           // Oggetto di tipo classe istanziato
  MiaClasse varB = new MiaClasse(); // Oggetto di tipo classe istanziato
\end{lstlisting}

\vspace{1em}
\subsection{Visibilità}
L’\textbf{identificatore} della classe e quello dei membri della classe sono sempre visibili all’interno della classe; tuttavia, un membro di una classe può avere uno dei modificatori seguenti:
\begin{itemize}
  \item \textbf{modificatore public}: membro visibile alle altre classi;
  \item \textbf{modificatore private}: membro \textbf{non} visibile alle altre classi.
\end{itemize}

\vspace{1em}
\subsection{Distruttori}
In Java \textbf{non esistono distruttori} (come per esempio in C++), per cui non avviene (come per la creazione) una distruzione esplicita degli oggetti ad opera del programmatore; il recupero della memoria dinamica non più utilizzata viene effettuata dalla piattaforma Java per mezzo di una specifica routine (il \textbf{Garbage Collector}).

\newpage
\noindent
\begin{lstlisting}[language=Java, caption=Esempio di multiclasse in Java]
  public class UsaConto
  {
    public static void main(String args[]) {
      ContoCorrente cc = new ContoCorrente(1000);

      cc.versa(700);

      if(cc.saldo>200)
        cc.preleva(200);
      if(cc.saldo>900)
        cc.preleva(900);

      System.out.println("Il saldo finale e': " + cc.saldo;
    }
  }

  public class ContoCorrente
  {
    public double saldo;

    public ContoCorrente(double saldoIniziale){
      this.saldo=saldoIniziale;
    }

    public void versa(double somma){
      this.saldo*=somma;
    }

    public void preleva(double somma){
      this.saldo-=somma;
    }
  }
\end{lstlisting}

\newpage
\noindent
\begin{center}
  5 Aprile 2022
\end{center}




\end{document}
